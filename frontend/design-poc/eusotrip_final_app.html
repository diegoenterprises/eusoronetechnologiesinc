<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EusoTrip - Revolutionary Logistics Platform</title>
    <meta name="description" content="A revolutionary, Einstein-inspired specialized trucking platform featuring world-class compliance verification, an integrated EusoWallet fintech system, and a sleek, Jony Ive-inspired design.">
    <meta name="author" content="Eusorone Technologies, Inc. - Designed by Mike 'Diego' Usoro">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-primary: #0D1117;
            --background-secondary: #161B22;
            --surface-primary: #1C2128;
            --text-primary: #C9D1D9;
            --text-secondary: #8B949E;
            --accent-primary-start: #58A6FF;
            --accent-primary-end: #A371F7;
            --border-primary: #30363D;
            --font-family-sans: 'Inter', sans-serif;
        }
        body {
            background-color: var(--background-primary);
            color: var(--text-primary);
            font-family: var(--font-family-sans);
            margin: 0;
        }
        #root {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .login-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
        }
        .login-container h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .login-container h2 { font-size: 1.2rem; color: var(--text-secondary); margin-bottom: 30px; }
        .login-container input {
            background: var(--surface-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            width: 100%;
            max-width: 350px;
            color: var(--text-primary);
            font-size: 1rem;
        }
        .login-container button {
            background: linear-gradient(90deg, var(--accent-primary-start), var(--accent-primary-end));
            border: none;
            border-radius: 8px;
            padding: 12px;
            width: 100%;
            max-width: 350px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 15px;
        }
        .demo-logins { text-align: center; }
        .demo-logins button {
             background: var(--surface-primary);
             width: auto;
             padding: 8px 12px;
             margin: 5px;
        }
        .app-layout { display: flex; height: 100%; }
        .sidebar {
            width: 260px;
            background-color: var(--background-secondary);
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-primary);
        }
        .sidebar .logo { display: flex; align-items: center; margin-bottom: 30px; }
        .sidebar .logo h1 { font-size: 1.5rem; font-weight: 700; }
        .sidebar nav ul { list-style: none; padding: 0; margin: 0; }
        .sidebar nav h6 { color: var(--text-secondary); text-transform: uppercase; font-size: 0.8rem; margin: 20px 0 10px 15px; }
        .sidebar nav li a { display: flex; align-items: center; padding: 12px 15px; color: var(--text-secondary); text-decoration: none; border-radius: 8px; margin-bottom: 5px; transition: all 0.2s ease; }
        .sidebar nav li a:hover { background-color: var(--surface-primary); color: var(--text-primary); }
        .sidebar nav li a.active { background: linear-gradient(90deg, var(--accent-primary-start), var(--accent-primary-end)); color: white; }
        .main-content { flex-grow: 1; display: flex; flex-direction: column; overflow-y: auto; }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-primary);
        }
        header .search-bar input {
            background-color: var(--surface-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 10px 15px;
            color: var(--text-primary);
            width: 300px;
        }
        header .user-profile { display: flex; align-items: center; }
        #dashboard-container { padding: 20px; }
        .esang-ai-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: linear-gradient(90deg, #58A6FF, #A371F7);
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }
        .esang-ai-button:hover { transform: scale(1.05); }
    </style>
</head>
<body>
    <div id="root"></div>
    <button class="esang-ai-button">Ask ESANG AI</button>
    <script>
        class EusoTripState {
  constructor() {
    this.state = {};
    this.subscribers = {};
    this.realtimeSubscribers = {};
    this.init();
  }

  init() {
    // Load initial state from localStorage or server
    const savedState = localStorage.getItem("eusoTripState");
    if (savedState) {
      this.state = JSON.parse(savedState);
    } else {
      // Default initial state
      this.state = {
        user: null,
        settings: { theme: "dark", notifications: true },
        activeShipments: [],
        notifications: []
      };
    }
    // Initialize WebSocket connection for real-time updates
    this.webSocketManager = new WebSocketManager(this); // Initialize WebSocket connection for real-time updates
    this.webSocketManager.connect(); // Establish connection on init
  }

  getState(key) {
    return key ? this.state[key] : this.state;
  }

  setState(newState, silent = false) {
    this.state = { ...this.state, ...newState };
    localStorage.setItem("eusoTripState", JSON.stringify(this.state));
    if (!silent) {
      this.notifySubscribers(Object.keys(newState));
    }
  }

  subscribe(key, callback) {
    if (!this.subscribers[key]) {
      this.subscribers[key] = [];
    }
    this.subscribers[key].push(callback);
    // Immediately call with current state for initial render
    // Immediately call with current state for initial render, ensuring the key exists
    if (this.state.hasOwnProperty(key)) {
      callback(this.state[key]);
    }
  }

  unsubscribe(key, callback) {
    if (this.subscribers[key]) {
      this.subscribers[key] = this.subscribers[key].filter(sub => sub !== callback);
    }
  }

  notifySubscribers(keys) {
    keys.forEach(key => {
      if (this.subscribers[key]) {
        this.subscribers[key].forEach(callback => callback(this.state[key]));
      }
    });
  }

  // Real-time updates
  subscribeToRealtimeUpdates(channel, callback) {
    if (!this.realtimeSubscribers[channel]) {
      this.realtimeSubscribers[channel] = [];
    }
    this.realtimeSubscribers[channel].push(callback);
    if (this.webSocketManager) {
      this.webSocketManager.subscribe(channel);
    }
  }

  unsubscribeFromRealtimeUpdates(channel, callback) {
    if (this.realtimeSubscribers[channel]) {
      this.realtimeSubscribers[channel] = this.realtimeSubscribers[channel].filter(sub => sub !== callback);
    }
    if (this.webSocketManager) {
      this.webSocketManager.unsubscribe(channel);
    }
  }

  handleRealtimeMessage(message) {
    const { channel, payload } = message;
    if (this.realtimeSubscribers[channel]) {
      this.realtimeSubscribers[channel].forEach(callback => callback(payload));
    }
    // Optionally update global state based on real-time message
    if (channel === "global_notifications") {
      this.setState({ notifications: [...this.state.notifications, payload] });
    }
  }

  // Global instance
  static getInstance() {
    if (!EusoTripState._instance) {
      EusoTripState._instance = new EusoTripState();
    }
    return EusoTripState._instance;
  }
}

// Expose a global instance for easy access
window.eusoTripState = EusoTripState.getInstance();

// Example usage:
// window.eusoTripState.subscribe("user", (user) => console.log("User updated:", user));
// window.eusoTripState.setState({ user: { name: "John Doe", id: "123" } });

class WebSocketManager {
  constructor(stateManager) {
    this.stateManager = stateManager;
    this.socket = null;
    this.channels = new Set();
    this.reconnectInterval = 5000; // 5 seconds
    this.init();
  }

  init() {
    this.connect();
  }

  connect() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      return;
    }
    const user = this.stateManager.getState("user");
    const token = user ? user.token : null; // Handle case where user or token is null
    const wsUrl = `${window.EUSOTRIP_CONFIG.wsBaseUrl}?token=${token}`;
    this.socket = new WebSocket(wsUrl);

    this.socket.onopen = () => {
      console.log("WebSocket connected.");
      this.channels.forEach(channel => this.send({ type: "subscribe", channel }));
    };

    this.socket.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.stateManager.handleRealtimeMessage(message);
    };

    this.socket.onclose = (event) => {
      console.warn("WebSocket disconnected:", event.code, event.reason);
      setTimeout(() => this.connect(), this.reconnectInterval);
    };

    this.socket.onerror = (error) => {
      console.error("WebSocket error:", error);
      this.socket.close();
    };
  }

  send(message) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      console.warn("WebSocket not open, message not sent:", message);
    }
  }

  subscribe(channel) {
    this.channels.add(channel);
    this.send({ type: "subscribe", channel });
  }

  unsubscribe(channel) {
    this.channels.delete(channel);
    this.send({ type: "unsubscribe", channel });
  }

  close() {
    if (this.socket) {
      this.socket.close();
    }
  }
}

class EusoTripAPI {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }

  async request(endpoint, method = "GET", data = null, customHeaders = {}) {
    const user = window.eusoTripState.getState("user");
    const headers = {
      "Content-Type": "application/json",
      ...(user?.token && { "Authorization": `Bearer ${user.token}` }),
      ...customHeaders
    };

    const config = {
      method,
      headers,
      ...(data && { body: JSON.stringify(data) })
    };

    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, config);
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `API Error: ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      console.error("API Request Error:", error);
      throw error;
    }
  }

  // Authentication
  login(credentials) {
    return this.request("/auth/login", "POST", credentials);
  }

  register(userData) {
    return this.request("/auth/register", "POST", userData);
  }

  logout() {
    // Invalidate token on server side if applicable
    window.eusoTripState.setState({ user: null });
    return Promise.resolve({ message: "Logged out successfully" });
  }

  // User Management
  getUserProfile(userId) {
    return this.request(`/users/${userId}`);
  }

  updateUserProfile(userId, profileData) {
    return this.request(`/users/${userId}`, "PUT", profileData);
  }

  // Shipment Management
  getShipments(query = {}) {
    const queryString = new URLSearchParams(query).toString();
    return this.request(`/shipments${queryString ? `?${queryString}` : ""}`);
  }

  createShipment(shipmentData) {
    return this.request("/shipments", "POST", shipmentData);
  }

  updateShipment(shipmentId, updateData) {
    return this.request(`/shipments/${shipmentId}`, "PUT", updateData);
  }

  deleteShipment(shipmentId) {
    return this.request(`/shipments/${shipmentId}`, "DELETE");
  }

  // Other API methods for various modules...
}

// Global API instance
window.eusoTripAPI = new EusoTripAPI(window.EUSOTRIP_CONFIG.apiBaseUrl);

class AuthManager {
  constructor(api, stateManager) {
    this.api = api;
    this.stateManager = stateManager;
    this.init();
  }

  init() {
    // Check for existing session on load
    const user = this.stateManager.getState("user");
    if (user && user.token) {
      // Optionally validate token with backend
      console.log("User session found.");
    }
  }

  async login(email, password) {
    try {
      const response = await this.api.login({ email, password });
      const user = { ...response.user, token: response.token };
      this.stateManager.setState({ user });
      return user;
    } catch (error) {
      console.error("Login failed:", error);
      throw error;
    }
  }

  async register(userData) {
    try {
      const response = await this.api.register(userData);
      const user = { ...response.user, token: response.token };
      this.stateManager.setState({ user });
      return user;
    } catch (error) {
      console.error("Registration failed:", error);
      throw error;
    }
  }

  async logout() {
    try {
      await this.api.logout();
      this.stateManager.setState({ user: null });
      console.log("User logged out.");
    } catch (error) {
      console.error("Logout failed:", error);
      throw error;
    }
  }

  isAuthenticated() {
    return !!this.stateManager.getState("user")?.token;
  }
}

window.eusoTripAuth = new AuthManager(window.eusoTripAPI, window.eusoTripState);

// Configuration for each user type\u0027s dashboard
const USER_DASHBOARD_CONFIGS = {
  SHIPPER: {
    workflows: ["material_details", "location_selection", "quote_insertion", "facility_book", "shipment_creation", "trailer_details", "job_procedure"],
    features: ["shipment_tracking", "billing_invoicing", "reporting_analytics", "document_management"],
    dashboardComponents: ["active_shipments", "shipment_history", "billing_summary", "analytics_overview", "notifications_feed"]
  },
  BROKER: {
    workflows: ["load_matching", "carrier_onboarding", "rate_negotiation", "dispatch_management"],
    features: ["carrier_network_access", "load_board_integration", "commission_tracking", "compliance_checks"],
    dashboardComponents: ["available_loads", "assigned_loads", "carrier_network", "commission_reports", "compliance_alerts"]
  },
  CATALYST: {
    workflows: ["trip_planning", "hos_tracking", "inspection_reporting", "fuel_management", "euso_wallet_integration"],
    features: ["realtime_navigation", "geofencing_alerts", "document_scanning", "maintenance_scheduling"],
    dashboardComponents: ["current_trip_status", "hos_dashboard", "earnings_summary", "maintenance_reminders", "euso_wallet_balance"]
  },
  CARRIER_DISPATCHER: {
    workflows: ["driver_assignment", "route_optimization", "fleet_tracking", "driver_communication"],
    features: ["load_dispatching", "driver_management", "performance_monitoring", "safety_compliance"],
    dashboardComponents: ["fleet_overview", "driver_status", "dispatched_loads", "performance_analytics", "safety_alerts"]
  },
  CARRIER_OWNER: {
    workflows: ["business_analytics", "driver_payroll", "asset_management", "insurance_management"],
    features: ["profit_loss_reporting", "driver_hiring", "vehicle_maintenance_tracking", "regulatory_compliance"],
    dashboardComponents: ["profit_loss_dashboard", "payroll_summary", "asset_utilization", "compliance_reports"]
  },
  DRIVER: {
    workflows: ["load_acceptance", "navigation", "delivery_confirmation", "hos_logging", "expense_reporting"],
    features: ["realtime_load_updates", "route_guidance", "document_upload", "e_logs", "per_diem_tracking"],
    dashboardComponents: ["current_load_details", "next_stops", "hos_status", "earnings_overview", "notifications"]
  },
  FLEET_MANAGER: {
    workflows: ["fleet_optimization", "driver_scheduling", "maintenance_planning", "fuel_efficiency_monitoring"],
    features: ["predictive_maintenance", "route_auditing", "driver_performance_reviews", "cost_analysis"],
    dashboardComponents: ["fleet_health", "driver_availability", "maintenance_schedule", "fuel_consumption_reports"]
  },
  COMPLIANCE_OFFICER: {
    workflows: ["regulatory_audits", "safety_training_management", "incident_reporting", "policy_enforcement"],
    features: ["realtime_compliance_alerts", "training_module_tracking", "incident_investigation_tools", "audit_trail"],
    dashboardComponents: ["compliance_dashboard", "training_status", "incident_log", "policy_updates"]
  },
  ACCOUNTING: {
    workflows: ["invoice_processing", "payment_reconciliation", "financial_reporting", "tax_preparation"],
    features: ["automated_invoicing", "payment_gateway_integration", "budget_vs_actual_analysis", "tax_document_generation"],
    dashboardComponents: ["accounts_receivable", "accounts_payable", "profit_loss_statements", "balance_sheet"]
  },
  HR: {
    workflows: ["employee_onboarding", "benefits_administration", "performance_management", "recruitment"],
    features: ["digital_onboarding", "employee_self-service_portal", "performance_review_tracking", "applicant_tracking_system"],
    dashboardComponents: ["employee_directory", "open_positions", "performance_reviews_due", "benefits_enrollment"]
  },
  SALES: {
    workflows: ["lead_management", "quote_generation", "customer_relationship_management", "sales_forecasting"],
    features: ["crm_integration", "automated_quoting", "sales_pipeline_tracking", "commission_calculator"],
    dashboardComponents: ["sales_pipeline", "new_leads", "customer_accounts", "sales_performance"]
  },
  CUSTOMER_SERVICE: {
    workflows: ["ticket_management", "issue_resolution", "customer_feedback_collection", "knowledge_base_management"],
    features: ["ai_powered_support", "ticket_escalation", "sentiment_analysis", "faq_management"],
    dashboardComponents: ["open_tickets", "resolved_tickets", "customer_satisfaction", "knowledge_base_updates"]
  },
  ADMIN: {
    workflows: ["user_management", "system_configuration", "security_monitoring", "data_backup_management"],
    features: ["role_based_access_control", "audit_logging", "intrusion_detection", "disaster_recovery"],
    dashboardComponents: ["system_status", "user_activity", "security_alerts", "backup_status"]
  },
  MAINTENANCE_MANAGER: {
    workflows: ["preventative_maintenance_scheduling", "repair_order_management", "parts_inventory_management", "vendor_management"],
    features: ["telematics_integration", "diagnostic_tools", "automated_parts_ordering", "maintenance_cost_analysis"],
    dashboardComponents: ["upcoming_maintenance", "open_repair_orders", "parts_inventory", "maintenance_history"]
  },
  WAREHOUSE_MANAGER: {
    workflows: ["inventory_management", "shipping_receiving", "order_fulfillment", "space_optimization"],
    features: ["barcode_scanning", "automated_picking", "realtime_inventory_tracking", "warehouse_layout_optimization"],
    dashboardComponents: ["current_inventory", "pending_orders", "shipping_schedule", "warehouse_utilization"]
  },
  FINANCE_MANAGER: {
    workflows: ["cash_flow_forecasting", "investment_analysis", "risk_management", "budget_allocation"],
    features: ["financial_modeling", "portfolio_management", "fraud_detection", "expense_tracking"],
    dashboardComponents: ["cash_flow_dashboard", "investment_portfolio", "risk_assessment", "budget_overview"]
  }
};

class DashboardGenerator {
  constructor(stateManager) {
    this.stateManager = stateManager;
    this.dashboardContainer = document.getElementById("dashboard-container");
    if (!this.dashboardContainer) {
      console.error("Dashboard container not found!");
      return;
    }
    this.stateManager.subscribe("user", this.renderDashboard.bind(this));
    this.renderDashboard(this.stateManager.getState("user"));
  }

  renderDashboard(user) {
    if (!user || !user.userType) {
      this.dashboardContainer.innerHTML = "<p>Please log in to view your dashboard.</p>";
      return;
    }

    const config = USER_DASHBOARD_CONFIGS[user.userType.toUpperCase()];
    if (!config) {
      this.dashboardContainer.innerHTML = `<p>No dashboard configuration found for user type: ${user.userType}</p>`;
      return;
    }

    let dashboardHtml = `<h2>Welcome, ${user.name}!</h2>`;

    // Render Workflows
    dashboardHtml += `<h3>Your Workflows:</h3><ul>`;
    config.workflows.forEach(workflow => {
      dashboardHtml += `<li>${this.formatName(workflow)}</li>`;
    });
    dashboardHtml += `</ul>`;

    // Render Features
    dashboardHtml += `<h3>Key Features:</h3><ul>`;
    config.features.forEach(feature => {
      dashboardHtml += `<li>${this.formatName(feature)}</li>`;
    });
    dashboardHtml += `</ul>`;

    // Render Dashboard Components (placeholders for now)
    dashboardHtml += `<h3>Dashboard Overview:</h3>`;
    config.dashboardComponents.forEach(component => {
      dashboardHtml += `<div class="dashboard-component"><h4>${this.formatName(component)}</h4><p>Content for ${this.formatName(component)}...</p></div>`;
    });

    this.dashboardContainer.innerHTML = dashboardHtml;
  }

  formatName(name) {
    return name.replace(/_/g, " ").replace(/\b\w/g, char => char.toUpperCase());
  }
}

// Initialize dashboard after state and API are ready
document.addEventListener("DOMContentLoaded", () => {
  // Ensure EUSOTRIP_CONFIG is defined globally or passed appropriately
  window.EUSOTRIP_CONFIG = {
    apiBaseUrl: "/api", // Example API base URL
    wsBaseUrl: "ws://localhost:3000/ws" // Example WebSocket base URL
  };

  // Initialize global state and API instances
  window.eusoTripState = EusoTripState.getInstance();
  window.eusoTripAPI = new EusoTripAPI(window.EUSOTRIP_CONFIG.apiBaseUrl);
  window.eusoTripAuth = new AuthManager(window.eusoTripAPI, window.eusoTripState);

  // Initialize Dashboard Generator
  new DashboardGenerator(window.eusoTripState);

  // --- START: Auto-Login Simulation for Preview ---
  // This block simulates a successful login for the SHIPPER role to display the dashboard structure.
  if (!window.eusoTripAuth.isAuthenticated()) {
    window.eusoTripState.setState({
      user: {
        name: "Marcus Johnson (SHIPPER)",
        userType: "SHIPPER", // Use one of the 16 defined types (e.g., SHIPPER, BROKER, CATALYST, DRIVER, ADMIN)
        token: "preview-token-12345"
      }
    });
  }
  // --- END: Auto-Login Simulation for Preview ---

  // Example of how to load SVG icons dynamically or via CSS if needed.
  // For now, these are commented out to remove embedded emoji/SVG code from JS.
  // loadSvgIcon("vl", "vl-icon-container");
  // loadSvgIcon("jp", "jp-icon-container");
  // loadSvgIcon("_p", "_p-icon-container");
  // loadSvgIcon("Op", "Op-icon-container");
  // loadSvgIcon("$p", "$p-icon-container");
  // loadSvgIcon("qp", "qp-icon-container");
});

// Function to load SVG icons dynamically
function loadSvgIcon(iconName, containerId) {
    fetch(`/icons/${iconName}.svg`)
        .then(response => response.text())
        .then(svg => {
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML = svg;
            } else {
                console.warn(`Container with ID ${containerId} not found for icon ${iconName}`);
            }
        })
        .catch(error => console.error(`Error loading ${iconName}.svg:`, error));
}

// Plausible Analytics script (kept as is, but can be externalized)
window.plausible =
    window.plausible ||
    function () {
        (window.plausible.q = window.plausible.q || []).push(arguments);
    };
plausible("custom-pageview", {
  props: {
        domain: window.location.host
  }
});

// ESANG AI Chatbot Integration (Placeholder - further implementation needed)
class EsangAIChatbot {
  constructor() {
    this.button = document.querySelector(".esang-ai-button");
    if (this.button) {
      this.button.addEventListener("click", this.openChat.bind(this));
    }
    console.log("ESANG AI Chatbot initialized.");
  }

  openChat() {
    alert("ESANG AI Chatbot: How can I help you today?");
    // Here, you would typically open a chat widget or navigate to a chat interface.
    // Further implementation would involve integrating with an actual chatbot service.
  }
}

document.addEventListener("DOMContentLoaded", () => {
  new EsangAIChatbot();
});

// General Utility Functions (Example: Xc for mobile detection, Bl, vt, Qt, tt, O for templating)
// These would typically come from a UI library or be defined globally if custom.
// For now, assuming they are available or will be provided by the framework.

// Placeholder for Xc, Bl, vt, Qt, tt, O if they are not globally available
function Xc() { return window.innerWidth <= 768; } // Example mobile detection

// Assuming Bl, vt, Qt, tt, O are part of a templating library like LitElement or similar.
// If not, these would need to be defined or replaced with standard DOM manipulation.
// For the purpose of this perfected code, we\u0027ll assume they are part of the environment.

// Example dummy implementations for templating functions if not using a library
function O(strings, ...values) {
  let str = \`\
  strings.forEach((string, i) => {
    str += string + (values[i] || \`\
  });
  return str;
}

function vt(template, shadowRoot) {
  if (shadowRoot) {
    shadowRoot.innerHTML = template;
  } else {
    console.warn("ShadowRoot not provided for vt function.");
  }
}

function Qt(callback) {
  // Placeholder for LitElement-like directive
  return `data-lit-directive="${callback.name}"`;
}

function tt(classes) {
  // Placeholder for LitElement-like class map
  return Object.entries(classes).filter(([, value]) => value).map(([key]) => key).join(\` \`);
}

class Bl { /* Base class for UI elements */ }

// Placeholder for Np and Bu functions if they are part of a specific framework initialization
function Np() { console.log("Np function called."); }
function Bu(callback) { callback(); }
        class EusoTripState {
  constructor() {
    this.state = {};
    this.subscribers = {};
    this.realtimeSubscribers = {};
    this.init();
  }

  init() {
    // Load initial state from localStorage or server
    const savedState = localStorage.getItem("eusoTripState");
    if (savedState) {
      this.state = JSON.parse(savedState);
    } else {
      // Default initial state
      this.state = {
        user: null,
        settings: { theme: "dark", notifications: true },
        activeShipments: [],
        notifications: []
      };
    }
    // Initialize WebSocket connection for real-time updates
    this.webSocketManager = new WebSocketManager(this); // Initialize WebSocket connection for real-time updates
    this.webSocketManager.connect(); // Establish connection on init
  }

  getState(key) {
    return key ? this.state[key] : this.state;
  }

  setState(newState, silent = false) {
    this.state = { ...this.state, ...newState };
    localStorage.setItem("eusoTripState", JSON.stringify(this.state));
    if (!silent) {
      this.notifySubscribers(Object.keys(newState));
    }
  }

  subscribe(key, callback) {
    if (!this.subscribers[key]) {
      this.subscribers[key] = [];
    }
    this.subscribers[key].push(callback);
    // Immediately call with current state for initial render
    // Immediately call with current state for initial render, ensuring the key exists
    if (this.state.hasOwnProperty(key)) {
      callback(this.state[key]);
    }
  }

  unsubscribe(key, callback) {
    if (this.subscribers[key]) {
      this.subscribers[key] = this.subscribers[key].filter(sub => sub !== callback);
    }
  }

  notifySubscribers(keys) {
    keys.forEach(key => {
      if (this.subscribers[key]) {
        this.subscribers[key].forEach(callback => callback(this.state[key]));
      }
    });
  }

  // Real-time updates
  subscribeToRealtimeUpdates(channel, callback) {
    if (!this.realtimeSubscribers[channel]) {
      this.realtimeSubscribers[channel] = [];
    }
    this.realtimeSubscribers[channel].push(callback);
    if (this.webSocketManager) {
      this.webSocketManager.subscribe(channel);
    }
  }

  unsubscribeFromRealtimeUpdates(channel, callback) {
    if (this.realtimeSubscribers[channel]) {
      this.realtimeSubscribers[channel] = this.realtimeSubscribers[channel].filter(sub => sub !== callback);
    }
    if (this.webSocketManager) {
      this.webSocketManager.unsubscribe(channel);
    }
  }

  handleRealtimeMessage(message) {
    const { channel, payload } = message;
    if (this.realtimeSubscribers[channel]) {
      this.realtimeSubscribers[channel].forEach(callback => callback(payload));
    }
    // Optionally update global state based on real-time message
    if (channel === "global_notifications") {
      this.setState({ notifications: [...this.state.notifications, payload] });
    }
  }

  // Global instance
  static getInstance() {
    if (!EusoTripState._instance) {
      EusoTripState._instance = new EusoTripState();
    }
    return EusoTripState._instance;
  }
}

// Expose a global instance for easy access
window.eusoTripState = EusoTripState.getInstance();

// Example usage:
// window.eusoTripState.subscribe("user", (user) => console.log("User updated:", user));
// window.eusoTripState.setState({ user: { name: "John Doe", id: "123" } });

class WebSocketManager {
  constructor(stateManager) {
    this.stateManager = stateManager;
    this.socket = null;
    this.channels = new Set();
    this.reconnectInterval = 5000; // 5 seconds
    this.init();
  }

  init() {
    this.connect();
  }

  connect() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      return;
    }
    const user = this.stateManager.getState("user");
    const token = user ? user.token : null; // Handle case where user or token is null
    const wsUrl = `${window.EUSOTRIP_CONFIG.wsBaseUrl}?token=${token}`;
    this.socket = new WebSocket(wsUrl);

    this.socket.onopen = () => {
      console.log("WebSocket connected.");
      this.channels.forEach(channel => this.send({ type: "subscribe", channel }));
    };

    this.socket.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.stateManager.handleRealtimeMessage(message);
    };

    this.socket.onclose = (event) => {
      console.warn("WebSocket disconnected:", event.code, event.reason);
      setTimeout(() => this.connect(), this.reconnectInterval);
    };

    this.socket.onerror = (error) => {
      console.error("WebSocket error:", error);
      this.socket.close();
    };
  }

  send(message) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      console.warn("WebSocket not open, message not sent:", message);
    }
  }

  subscribe(channel) {
    this.channels.add(channel);
    this.send({ type: "subscribe", channel });
  }

  unsubscribe(channel) {
    this.channels.delete(channel);
    this.send({ type: "unsubscribe", channel });
  }

  close() {
    if (this.socket) {
      this.socket.close();
    }
  }
}

class EusoTripAPI {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }

  async request(endpoint, method = "GET", data = null, customHeaders = {}) {
    const user = window.eusoTripState.getState("user");
    const headers = {
      "Content-Type": "application/json",
      ...(user?.token && { "Authorization": `Bearer ${user.token}` }),
      ...customHeaders
    };

    const config = {
      method,
      headers,
      ...(data && { body: JSON.stringify(data) })
    };

    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, config);
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `API Error: ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      console.error("API Request Error:", error);
      throw error;
    }
  }

  // Authentication
  login(credentials) {
    return this.request("/auth/login", "POST", credentials);
  }

  register(userData) {
    return this.request("/auth/register", "POST", userData);
  }

  logout() {
    // Invalidate token on server side if applicable
    window.eusoTripState.setState({ user: null });
    return Promise.resolve({ message: "Logged out successfully" });
  }

  // User Management
  getUserProfile(userId) {
    return this.request(`/users/${userId}`);
  }

  updateUserProfile(userId, profileData) {
    return this.request(`/users/${userId}`, "PUT", profileData);
  }

  // Shipment Management
  getShipments(query = {}) {
    const queryString = new URLSearchParams(query).toString();
    return this.request(`/shipments${queryString ? `?${queryString}` : ""}`);
  }

  createShipment(shipmentData) {
    return this.request("/shipments", "POST", shipmentData);
  }

  updateShipment(shipmentId, updateData) {
    return this.request(`/shipments/${shipmentId}`, "PUT", updateData);
  }

  deleteShipment(shipmentId) {
    return this.request(`/shipments/${shipmentId}`, "DELETE");
  }

  // Other API methods for various modules...
}

// Global API instance
window.eusoTripAPI = new EusoTripAPI(window.EUSOTRIP_CONFIG.apiBaseUrl);

class AuthManager {
  constructor(api, stateManager) {
    this.api = api;
    this.stateManager = stateManager;
    this.init();
  }

  init() {
    // Check for existing session on load
    const user = this.stateManager.getState("user");
    if (user && user.token) {
      // Optionally validate token with backend
      console.log("User session found.");
    }
  }

  async login(email, password) {
    try {
      const response = await this.api.login({ email, password });
      const user = { ...response.user, token: response.token };
      this.stateManager.setState({ user });
      return user;
    } catch (error) {
      console.error("Login failed:", error);
      throw error;
    }
  }

  async register(userData) {
    try {
      const response = await this.api.register(userData);
      const user = { ...response.user, token: response.token };
      this.stateManager.setState({ user });
      return user;
    } catch (error) {
      console.error("Registration failed:", error);
      throw error;
    }
  }

  async logout() {
    try {
      await this.api.logout();
      this.stateManager.setState({ user: null });
      console.log("User logged out.");
    } catch (error) {
      console.error("Logout failed:", error);
      throw error;
    }
  }

  isAuthenticated() {
    return !!this.stateManager.getState("user")?.token;
  }
}

window.eusoTripAuth = new AuthManager(window.eusoTripAPI, window.eusoTripState);

// Configuration for each user type\u0027s dashboard
const USER_DASHBOARD_CONFIGS = {
  SHIPPER: {
    workflows: ["material_details", "location_selection", "quote_insertion", "facility_book", "shipment_creation", "trailer_details", "job_procedure"],
    features: ["shipment_tracking", "billing_invoicing", "reporting_analytics", "document_management"],
    dashboardComponents: ["active_shipments", "shipment_history", "billing_summary", "analytics_overview", "notifications_feed"]
  },
  BROKER: {
    workflows: ["load_matching", "carrier_onboarding", "rate_negotiation", "dispatch_management"],
    features: ["carrier_network_access", "load_board_integration", "commission_tracking", "compliance_checks"],
    dashboardComponents: ["available_loads", "assigned_loads", "carrier_network", "commission_reports", "compliance_alerts"]
  },
  CATALYST: {
    workflows: ["trip_planning", "hos_tracking", "inspection_reporting", "fuel_management", "euso_wallet_integration"],
    features: ["realtime_navigation", "geofencing_alerts", "document_scanning", "maintenance_scheduling"],
    dashboardComponents: ["current_trip_status", "hos_dashboard", "earnings_summary", "maintenance_reminders", "euso_wallet_balance"]
  },
  CARRIER_DISPATCHER: {
    workflows: ["driver_assignment", "route_optimization", "fleet_tracking", "driver_communication"],
    features: ["load_dispatching", "driver_management", "performance_monitoring", "safety_compliance"],
    dashboardComponents: ["fleet_overview", "driver_status", "dispatched_loads", "performance_analytics", "safety_alerts"]
  },
  CARRIER_OWNER: {
    workflows: ["business_analytics", "driver_payroll", "asset_management", "insurance_management"],
    features: ["profit_loss_reporting", "driver_hiring", "vehicle_maintenance_tracking", "regulatory_compliance"],
    dashboardComponents: ["profit_loss_dashboard", "payroll_summary", "asset_utilization", "compliance_reports"]
  },
  DRIVER: {
    workflows: ["load_acceptance", "navigation", "delivery_confirmation", "hos_logging", "expense_reporting"],
    features: ["realtime_load_updates", "route_guidance", "document_upload", "e_logs", "per_diem_tracking"],
    dashboardComponents: ["current_load_details", "next_stops", "hos_status", "earnings_overview", "notifications"]
  },
  FLEET_MANAGER: {
    workflows: ["fleet_optimization", "driver_scheduling", "maintenance_planning", "fuel_efficiency_monitoring"],
    features: ["predictive_maintenance", "route_auditing", "driver_performance_reviews", "cost_analysis"],
    dashboardComponents: ["fleet_health", "driver_availability", "maintenance_schedule", "fuel_consumption_reports"]
  },
  COMPLIANCE_OFFICER: {
    workflows: ["regulatory_audits", "safety_training_management", "incident_reporting", "policy_enforcement"],
    features: ["realtime_compliance_alerts", "training_module_tracking", "incident_investigation_tools", "audit_trail"],
    dashboardComponents: ["compliance_dashboard", "training_status", "incident_log", "policy_updates"]
  },
  ACCOUNTING: {
    workflows: ["invoice_processing", "payment_reconciliation", "financial_reporting", "tax_preparation"],
    features: ["automated_invoicing", "payment_gateway_integration", "budget_vs_actual_analysis", "tax_document_generation"],
    dashboardComponents: ["accounts_receivable", "accounts_payable", "profit_loss_statements", "balance_sheet"]
  },
  HR: {
    workflows: ["employee_onboarding", "benefits_administration", "performance_management", "recruitment"],
    features: ["digital_onboarding", "employee_self_service_portal", "performance_review_tracking", "applicant_tracking_system"],
    dashboardComponents: ["employee_directory", "open_positions", "performance_reviews_due", "benefits_enrollment"]
  },
  SALES: {
    workflows: ["lead_management", "quote_generation", "customer_relationship_management", "sales_forecasting"],
    features: ["crm_integration", "automated_quoting", "sales_pipeline_tracking", "commission_calculator"],
    dashboardComponents: ["sales_pipeline", "new_leads", "customer_accounts", "sales_performance"]
  },
  CUSTOMER_SERVICE: {
    workflows: ["ticket_management", "issue_resolution", "customer_feedback_collection", "knowledge_base_management"],
    features: ["ai_powered_support", "ticket_escalation", "sentiment_analysis", "faq_management"],
    dashboardComponents: ["open_tickets", "resolved_tickets", "customer_satisfaction", "knowledge_base_updates"]
  },
  ADMIN: {
    workflows: ["user_management", "system_configuration", "security_monitoring", "data_backup_management"],
    features: ["role_based_access_control", "audit_logging", "intrusion_detection", "disaster_recovery"],
    dashboardComponents: ["system_status", "user_activity", "security_alerts", "backup_status"]
  },
  MAINTENANCE_MANAGER: {
    workflows: ["preventative_maintenance_scheduling", "repair_order_management", "parts_inventory_management", "vendor_management"],
    features: ["telematics_integration", "diagnostic_tools", "automated_parts_ordering", "maintenance_cost_analysis"],
    dashboardComponents: ["upcoming_maintenance", "open_repair_orders", "parts_inventory", "maintenance_history"]
  },
  WAREHOUSE_MANAGER: {
    workflows: ["inventory_management", "shipping_receiving", "order_fulfillment", "space_optimization"],
    features: ["barcode_scanning", "automated_picking", "realtime_inventory_tracking", "warehouse_layout_optimization"],
    dashboardComponents: ["current_inventory", "pending_orders", "shipping_schedule", "warehouse_utilization"]
  },
  FINANCE_MANAGER: {
    workflows: ["cash_flow_forecasting", "investment_analysis", "risk_management", "budget_allocation"],
    features: ["financial_modeling", "portfolio_management", "fraud_detection", "expense_tracking"],
    dashboardComponents: ["cash_flow_dashboard", "investment_portfolio", "risk_assessment", "budget_overview"]
  }
};

class DashboardGenerator {
  constructor(stateManager) {
    this.stateManager = stateManager;
    this.dashboardContainer = document.getElementById("dashboard-container");
    if (!this.dashboardContainer) {
      console.error("Dashboard container not found!");
      return;
    }
    this.stateManager.subscribe("user", this.renderDashboard.bind(this));
    this.renderDashboard(this.stateManager.getState("user"));
  }

  renderDashboard(user) {
    if (!user || !user.userType) {
      this.dashboardContainer.innerHTML = "<p>Please log in to view your dashboard.</p>";
      return;
    }

    const config = USER_DASHBOARD_CONFIGS[user.userType.toUpperCase()];
    if (!config) {
      this.dashboardContainer.innerHTML = `<p>No dashboard configuration found for user type: ${user.userType}</p>`;
      return;
    }

    let dashboardHtml = `<h2>Welcome, ${user.name}!</h2>`;

    // Render Workflows
    dashboardHtml += `<h3>Your Workflows:</h3><ul>`;
    config.workflows.forEach(workflow => {
      dashboardHtml += `<li>${this.formatName(workflow)}</li>`;
    });
    dashboardHtml += `</ul>`;

    // Render Features
    dashboardHtml += `<h3>Key Features:</h3><ul>`;
    config.features.forEach(feature => {
      dashboardHtml += `<li>${this.formatName(feature)}</li>`;
    });
    dashboardHtml += `</ul>`;

    // Render Dashboard Components (placeholders for now)
    dashboardHtml += `<h3>Dashboard Overview:</h3>`;
    config.dashboardComponents.forEach(component => {
      dashboardHtml += `<div class="dashboard-component"><h4>${this.formatName(component)}</h4><p>Content for ${this.formatName(component)}...</p></div>`;
    });

    this.dashboardContainer.innerHTML = dashboardHtml;
  }

  formatName(name) {
    return name.replace(/_/g, " ").replace(/\b\w/g, char => char.toUpperCase());
  }
}

// Initialize dashboard after state and API are ready
document.addEventListener("DOMContentLoaded", () => {
  // Ensure EUSOTRIP_CONFIG is defined globally or passed appropriately
  window.EUSOTRIP_CONFIG = {
    apiBaseUrl: "/api", // Example API base URL
    wsBaseUrl: "ws://localhost:3000/ws" // Example WebSocket base URL
  };

  // Initialize global state and API instances
  window.eusoTripState = EusoTripState.getInstance();
  window.eusoTripAPI = new EusoTripAPI(window.EUSOTRIP_CONFIG.apiBaseUrl);
  window.eusoTripAuth = new AuthManager(window.eusoTripAPI, window.eusoTripState);

  // Initialize Dashboard Generator
  new DashboardGenerator(window.eusoTripState);

  // --- START: Auto-Login Simulation for Preview ---
  // This block simulates a successful login for the SHIPPER role to display the dashboard structure.
  if (!window.eusoTripAuth.isAuthenticated()) {
    window.eusoTripState.setState({
      user: {
        name: "Marcus Johnson (SHIPPER)",
        userType: "SHIPPER", // Use one of the 16 defined types (e.g., SHIPPER, BROKER, CATALYST, DRIVER, ADMIN)
        token: "preview-token-12345"
      }
    });
  }
  // --- END: Auto-Login Simulation for Preview ---

  // Example of how to load SVG icons dynamically or via CSS if needed.
  // For now, these are commented out to remove embedded emoji/SVG code from JS.
  // loadSvgIcon("vl", "vl-icon-container");
  // loadSvgIcon("jp", "jp-icon-container");
  // loadSvgIcon("_p", "_p-icon-container");
  // loadSvgIcon("Op", "Op-icon-container");
  // loadSvgIcon("$p", "$p-icon-container");
  // loadSvgIcon("qp", "qp-icon-container");
});

// Function to load SVG icons dynamically
function loadSvgIcon(iconName, containerId) {
    fetch(`/icons/${iconName}.svg`)
        .then(response => response.text())
        .then(svg => {
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML = svg;
            } else {
                console.warn(`Container with ID ${containerId} not found for icon ${iconName}`);
            }
        })
        .catch(error => console.error(`Error loading ${iconName}.svg:`, error));
}

// Plausible Analytics script (kept as is, but can be externalized)
window.plausible =
    window.plausible ||
    function () {
        (window.plausible.q = window.plausible.q || []).push(arguments);
    };
plausible("custom-pageview", {
  props: {
        domain: window.location.host
  }
});

// ESANG AI Chatbot Integration (Placeholder - further implementation needed)
class EsangAIChatbot {
  constructor() {
    this.button = document.querySelector(".esang-ai-button");
    if (this.button) {
      this.button.addEventListener("click", this.openChat.bind(this));
    }
    console.log("ESANG AI Chatbot initialized.");
  }

  openChat() {
    alert("ESANG AI Chatbot: How can I help you today?");
    // Here, you would typically open a chat widget or navigate to a chat interface.
    // Further implementation would involve integrating with an actual chatbot service.
  }
}

document.addEventListener("DOMContentLoaded", () => {
  new EsangAIChatbot();
});

// General Utility Functions (Example: Xc for mobile detection, Bl, vt, Qt, tt, O for templating)
// These would typically come from a UI library or be defined globally if custom.
// For now, assuming they are available or will be provided by the framework.

// Placeholder for Xc, Bl, vt, Qt, tt, O if they are not globally available
function Xc() { return window.innerWidth <= 768; } // Example mobile detection

// Assuming Bl, vt, Qt, tt, O are part of a templating library like LitElement or similar.
// If not, these would need to be defined or replaced with standard DOM manipulation.
// For the purpose of this perfected code, we\'ll assume they are part of the environment.

// Example dummy implementations for templating functions if not using a library
function O(strings, ...values) {
  let str = \'\';
  strings.forEach((string, i) => {
    str += string + (values[i] || \'\');
  });
  return str;
}

function vt(template, shadowRoot) {
  if (shadowRoot) {
    shadowRoot.innerHTML = template;
  } else {
    console.warn("ShadowRoot not provided for vt function.");
  }
}

function Qt(callback) {
  // Placeholder for LitElement-like directive
  return `data-lit-directive="${callback.name}"`;
}

function tt(classes) {
  // Placeholder for LitElement-like class map
  return Object.entries(classes).filter(([, value]) => value).map(([key]) => key).join(\' \');
}

class Bl { /* Base class for UI elements */ }

// Placeholder for Np and Bu functions if they are part of a specific framework initialization
function Np() { console.log("Np function called."); }
function Bu(callback) { callback(); }
    </script>
</body>
</html>
